===================
04 - Event Handling
===================

Processing Input Events
-----------------------

#. Dispatch events from user to correct application/window
#. Event/code binding
#. Redraw the presentation

Event/Code Binding
------------------

* Number of different approaces used to map from event to code
* The selected method should work well with interface design tools, and make
  the most of the language
* The emphasis has shifted from efficiency to ability to handle complexity of
  large applications
* Historical development is often to integrate methods into the programming
  language used

Event Queue and Type Selection
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Event loop is manually programmed, by using a switch statement to act on the
type of event that is generated.

This is quite efficient, and is still used today on some mobile devices.

Window Event Tables
^^^^^^^^^^^^^^^^^^^

Developed for Sun's GIGO windowing system (1983).

Each window is linked to a table of procedures (using pointers in C). Each
table is indexed by event 'type'. All events carry the mouse position in the
payload.

GIGO searches the window tree top-down (front to back) and *everything* was
driven by the mouse (even keyboard input had to be directed to the window which
was under the mouse!).

If an event handler is not found for the lowest level, frontmost window, it is
'promoted' to the parent window, until a handler is found. This is called
*bottom-up event promotion*.

Callback Event Handling
-----------------------

Used in X Windows (1986).

The programmer associates a name with each event handling procedure address.
The window properties then include those names.

On initialisation, the system retrieves the addresses, and uses them as event
tables.

Design tools can use the names and clear errors can be generated if a callback
is missing, making the system much easier to debug.

Winproc Event Handling
----------------------

Central to Microsoft Windows.

Each window is associated with a single procedure's address, which handles all
events for that window.

Winproc typically contains a ``switch`` statement, which are specific to the
window's type (not generic).

This is more modular than the generic switch statement solution, and as easy to
implement as event tables. However, it is opaque to design tools.

Inheritance Event Handling
--------------------------

So far, the emphasis has been on *windows*, and not *widgets*.

SmallTalk-80 introduced OOP, which is the basis of most current toolkits.

The windowing system must be able to deal with any widget at any time. All
object-oriented widgets provide a common interface::

    public class Widget
    {
        public void mousePressed(int x, int y, int buttonNumber)
        
        public void mouseReleased(int x, int y, int buttonNumber)
        
        public void mouseMoved(int x, int y)
        
        public void keyPressed(char c, int x, int y, int modifiers)
        
        public void windowClosed()
        
        public void redraw( Graphics toDraw)
    }

Listeners
---------

There are many more events than just those generated by the use at the keyboard
or mouse. For example, a device being plugged in, a window being moved, etc.

This means that widgets have to choose between many thousands of different
events.

To allow this to work, the listener model is used to allow widgets to 'listen'
for a specific type of event, ignoring all other types.

Model/View Notification
-----------------------

So far the user has generated an event, and this event has been queued by the
O/S, extracted by the windowing system, sent to the app and then the app has
executed some code to respond to this event. To complete the cycle...

The controller consults the *essential geometry*, and decides on a change to
the model. It then invokes one of the model's public methods to change it in
some way.

The model must then change itself, and notify the view of these changes. The
view must then notify the windowing system of a piece of the screen that must
be redrawn.
